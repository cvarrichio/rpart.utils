{
    "contents" : "#' Writes rule tables required to process rpart rules in SQL to an open RODBC connection.\n#'\n#'  This function handles the process of pushing tabular versions of\n#'  \\pkg{rpart} rules to an RODBC connection.  The entire process of generation\n#'  and writing is completed with a single call, with all necessary subcalls\n#'  handled within this function. \n#'  \n#'  Once the tables have been pushed to the database, unpivoted source data can\n#'  be processed using the rpart model with SQL code similar to the following:\n#'  \n#'\\preformatted{\n#' WITH SOURCE AS\n#' (\n#'     SELECT\n#'     ID,\n#'     TYPE,\n#'     VALUE\n#'     FROM DATA\n#'     UNPIVOT\n#'     (\n#'         VALUE FOR TYPE IN (FIELD1, FIELD2, FIELD3)\n#'     )UNPVT\n#' ),\n#' MATCHES AS \n#' (\n#'     SELECT\n#'     ID\n#'     ,Subrule\n#'     ,Variable\n#'     ,SR.Value\n#'     ,Less\n#'     ,Greater\n#'     FROM\n#'     SOURCE S\n#'     LEFT JOIN SUBRULES SR\n#'     ON\n#'     TYPE = VARIABLE\n#'     AND (\n#'         S.value = SR.value\n#'         OR S.value < SR.Less\n#'         OR S.value > SR.Greater\n#'         ) \n#'     ),\n#' MATCHED_SUBRULES\n#' AS (\n#'     SELECT\n#'     Subrule\n#'     ,ID\n#'     FROM\n#'     MATCHES M\n#'     GROUP BY\n#'     Subrule\n#'     ,ID\n#'     ),\n#' MATCHED_RULES\n#' AS (\n#'     SELECT\n#'     R.[Rule]\n#'     ,MS.*\n#'     FROM\n#'     RULES AS R\n#'     LEFT JOIN MATCHED_SUBRULES MS\n#'     ON R.SUBRULE=MS.SUBRULE AND Leaf='TRUE'\n#'     )\n#' ,\n#' COUNTS AS\n#' (\n#'     SELECT\n#'     [RULE]\n#'     ,ID\n#'     ,MATCH_COUNT=COUNT(DISTINCT SUBRULE)\n#'     ,NEEDED_COUNT=(SELECT COUNT(DISTINCT SUBRULE) FROM RULES R WHERE R.[RULE]=MR.[RULE])\n#'     FROM\n#'     MATCHED_RULES MR\n#'     GROUP BY\n#'     [RULE]\n#'     ,ID\n#'     )\n#' SELECT \n#' RULE\n#' ,ID\n#' FROM COUNTS\n#' WHERE \n#' MATCH_COUNT=NEEDED_COUNT \n#'}\n#'\n#' The frame is also passed to the database which allows extracting the estimates generated by the rpart model.\n#'\n#' @param object an rpart object\n#' @param connection and open RODBC connection\n#' @param rulePrefix A character string to prepend to each rule name to allow for multiple rule sets\n#' @param tablePrefix A character string to prepend to each table name to allow for multiple rule sets\n#' @export\nrpart.rules.push<-function(object,connection,rulePrefix=NULL,tablePrefix=NULL)\n{\n  require(RODBC)\n  rulePrefix<-paste2(rulePrefix,'',sep='.')\n  rules<-rpart.rules.table(object)\n  rules$Rule<-paste(rulePrefix,rules$Rule,sep='')\n  rules$Subrule<-paste(rulePrefix,rules$Subrule,sep='')\n  sqlSave(connection,rules,tablename=paste2(tablePrefix,\"RULES\",sep='_'),append=TRUE,rownames=FALSE)\n  subrules<-rpart.subrules.table(object)\n  subrules$Subrule<-paste(rulePrefix,subrules$Subrule,sep='')\n  sqlSave(connection,subrules,tablename=paste2(tablePrefix,\"SUBRULES\",sep='_'),append=TRUE,rownames=FALSE)\n  frame<-object$frame\n  if (!is.null(frame$yval2))\n      frame<-cbind(frame[,names(frame) != \"yval2\"],frame$yval2)\n  frame$Rule<-paste(rulePrefix,row.names(frame),sep='')\n  sqlSave(connection,frame,tablename=paste2(tablePrefix,\"FRAME\",sep='_'),append=TRUE,rownames=FALSE)\n}\n\npaste2<-function(...,sep=' ')\n{\n  args<-unlist(list(...))\n  result<-paste(args,collapse=sep)\n  return(result)\n}",
    "created" : 1400103446936.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3536353139",
    "id" : "BADBDB0E",
    "lastKnownWriteTime" : 1400703520,
    "path" : "~/Analytics/Source/rpart.utils/R/rpart.rules.push.R",
    "project_path" : "R/rpart.rules.push.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}